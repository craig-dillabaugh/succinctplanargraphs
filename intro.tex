% EDITING GUIDELINES
%
% * Limit lines to no more than 100 characters.  The default should be
%   80 characters.  This leaves room for the addition of 20 new
%   characters on the same line later on.
%
%   RATIONALE: Long lines are hard to read and cause trouble when
%   viewing two versions of the file side by side (e.g., using vimdiff)
%
% * Start every sentence on a new line.
%
%   RATIONALE: This makes sentences so much easier to find using forward
%   search in emacs or vim.
%
% * Do not justify paragraphs.  Particularly, when editing an existing
%   version of the text, do not change line breaks apart from adding
%   line breaks for lines that would otherwise be too long.
%
%   RATIONALE: This makes changes from previous versions so much easier
%   to identify, particularly when using a VCS.  Adding a word and
%   justifying the paragraph may change all the lines in the paragraph,
%   making this look like a huge edit.  Without justification, the
%   diff shows only the addition of the one word.

% ------------------------------------------------------------------------------
\section{Introduction}
% ------------------------------------------------------------------------------

External memory (EM) data structures and succinct data structures both
address the problem of representing very large data sets.
In the EM model, the goal is to structure data that are too large to fit into
internal memory in a way that minimizes the transfer of data between
internal and external memory when answering certain queries.
For succinct data structures, the aim is to encode the structural
component of the data structure using as little space as is
theoretically possible while still permitting efficient navigation of
the structure.
Thus, EM data structures deal with the I/O bottleneck
that arises when the data are too large to fit into memory, while
succinct data structures help to avoid this bottleneck as they allow
more data to be stored in memory.
Succinct EM data structures maximize the amount of data that fits on a disk of
a given size or in a disk block.
The former is important because an increasing number of
large-scale applications find themselves limited by the amount of data
that fits on a disk.
The latter helps to reduce the I/O bottleneck further, as more data
can be swapped between memory and disk in a single I/O operation.

In this paper, we develop a succinct EM data structure for path
traversal in planar graphs.
Given a bounded-degree planar graph $G$,
our goal is to simultaneously minimize the amount of space used to
store $G$ on disk as well as the number of I/O operations required to report
a path of length $K$ in $G$.
As practical applications of our
structure, we show how it can be used to answer a range of important
queries on triangular irregular network (TIN) models of terrains.

% ------------------------------------------------------------------------------
\subsection{Background}\label{sec:background}
% ------------------------------------------------------------------------------

In the \emph{external memory} (EM) model \cite{DBLP:journals/cacm/AggarwalV88}, the
computer is assumed to be equipped with a two-level memory hierarchy
consisting of \emph{internal} and (disk-based) \emph{external memory}.
The external memory is assumed to have infinite size, but accessing data
elements in external memory is several orders of magnitude slower than accessing
data in internal memory.
Conversely, while internal memory permits efficient operations, its size is limited
to $M$ data elements.
Data is transferred between internal and external memory by means of
\emph{I/O operations} (\emph{I/Os} for short), each of which transfers
a block of $B$ consecutive data items. 
The efficiency of a data structure in the EM model is measured in terms of the
space it uses and the number of I/Os required to answer certain queries.
In order to take advantage of blockwise disk accesses, it is necessary that $M
\ge B$.
In this paper, we assume $M \ge 2B$ and $B = \OmegaOf{\lg N}$,
where $N$ denotes the input size. Furthermore, we assume that the machine
word size is $\wsize = \Theta(\lg N)$ bits, an assumption commonly used 
in papers on succinct data structures in internal 
memory~\cite{DBLP:journals/talg/RamanRS07}.

Nodine~\etal~\cite{ngv_1996} first explored the problem of blocking
graphs in external memory for efficient path traversal. They store the
 graph in disk blocks (possibly with duplication of
vertices and edges) so that any path in the graph could be traversed
using few I/Os relative to the path's length.
The efficiency of the blocking is expressed in terms
of the \emph{blocking speed-up}, which is the minimum ratio between
the length of a traversed path and the number of I/Os required to
traverse it, taken over all paths that require more than $c$ I/Os to
traverse, for some constant $c$, and assuming that only one block can
be held in memory at any point in time.
The authors identified the optimal bounds for the worst-case blocking speed-up
for several classes of graphs.
Agarwal \etal~\cite{DBLP:conf/soda/AgarwalAMVV98} proposed a
blocking of bounded-degree planar graphs such that any path of length
$K$ can be traversed using $\OhOf{K / \lg B}$ I/Os.

Succinct data structures represent their structural
components using space as near the information-theoretic lower bound as
possible while still permitting efficient operations.
These were originally proposed by Jacobson
\cite{jac_1989}, who designed succinct representations of trees and
graphs.
To represent graphs, Jacobson relied on the technique of book
embeddings by Bernhart and Kainen
\cite{DBLP:journals/jct/BernhartK79}.
A $k$-page book embedding of a graph is an ordering of the graph's vertices,
along with a partition of its edges into $k$ ``pages'',
each of which is a subset of edges that induces an outerplanar embedding of
the graph consistent with the chosen vertex ordering.
Yannakakis \cite{DBLP:conf/stoc/Yannakakis86}
demonstrated that $k=4$ is necessary and sufficient to partition
planar graphs.
Jacobson's data structure embeds each page of a graph
on $N$ vertices using $\OhOf{N}$ bits, and can thus represent
$k$-page graphs using $\OhOf{kN}$ bits and planar graphs using
$\OhOf{N}$ bits.
The structure supports adjacency queries using
$\OhOf{\lg N}$ bit probes, and the listing of the neighbours of a
vertex $v$ of degree $\deg{v}$ using $\OhOf{\deg{v} \lg N + k}$ bit
probes.

Jacobson's result was improved upon by Munro and Raman
\cite{DBLP:conf/focs/MunroR97} under the word-RAM model.
They showed how to represent a $k$-page graph with $N$ vertices and $M$ edges
using $2kN + 2M + \ohOf{Nk + M}$ bits such that adjacency and
vertex degree queries can be answered in $\OhOf{k}$ time.
The neighbours of a vertex $v$ can be reported in $\OhOf{d(v)+k}$ time.
For planar graphs, this result translates to an $(8N + 2M + \ohOf{N+M})$-bit
representation that answers adjacency and degree queries in constant
time, and lists neighbours in $\OhOf{\deg{v}}$ time.
Gavoille and Hanusse \cite{DBLP:journals/dmtcs/GavoilleH08} proposed an encoding
for $M$-edge $k$-page-embeddable graphs that allows multiple edges and
loops.
For a graph with no isolated vertices, their structure uses $2M
\lg k + 4M$ bits, which is an improvement over Munro and Raman's
structure whenever $M \le kN / (2\lg k)$.
By adding an auxiliary table of $\ohOf{M \lg k}$ bits, this encoding
supports calculating vertex degrees in constant time, answering adjacency
queries in $\OhOf{\lg k}$ time (constant for planar graphs), and
accessing all neighbours of a vertex in $\OhOf{\deg{v}}$ time.

An alternate approach to book embeddings of planar graphs, which uses
canonical orderings of the graph's vertices and edges, was presented
by Chuang \etal~\cite{chuang_et_al_1998}.
Their solution represents a planar graph using
$2M + (5 + 1/\epsilon)N + \ohOf{M + N}$ bits, for any $\epsilon > 0$ 
(with $\epsilon = \OhOf{1}$), and supports constant-time adjacency 
and degree queries.
If the graph is simple, this bound becomes
$\frac{5}{3}M + (5 + 1/\epsilon)N + ohOf{N}$. 
For triangulated planar graphs, they reduced the space
bound to $2M + 2N + \ohOf{N}$ bits.
The space bound for general planar graphs was reduced by Chiang
\etal~\cite{DBLP:journals/siamcomp/ChiangLL05}, who showed that a
graph with no multiple edges or self loops can be represented using
$2M + 2N + \ohOf{M + N}$ bits to support the same set of
operations.
For the case of triangulated planar graphs, Yamanaka and
Nakano~\cite{DBLP:conf/walcom/YamanakaN08} presented an encoding that
uses $2N + \ohOf{M}$ bits and supports adjacency, degree, and
clockwise neighbour queries in constant time.

Barbay \etal~\cite{DBLP:conf/isaac/BarbayAHM07} presented several
results with respect to both planar graphs, triangulations, and
$k$-page graphs, including the first results for labeled graphs and
triangulations.
For planar triangulations, they added support for
rank/select queries of edges in counterclockwise order using $2M
\lg 6 + \ohOf{M}$ bits.
For plane graphs, their structures support
standard queries, as well as rank/select queries in counterclockwise
order, using $3N(2 \lg 3 + 3 + \epsilon) + \ohOf{N}$
bits (for $0 < \epsilon < 1$).
For $k$-page graphs
with large values of $k$, they proposed a representation using $N + 2M
\lg k + M \cdot \ohOf{\lg k} + \OhOf{M}$ bits and supporting
adjacency queries in $\OhOf{\lg k \lg\lg k}$ time, degree queries in
constant time, and the listing of neighbours in $\OhOf{\deg{v} \lg\lg k}$ time.
An alternative representation uses
$N + (2 + \epsilon)M \lg k + M \cdot \ohOf{\lg k} + \OhOf{M}$ bits and
supports adjacency queries in $\OhOf{\lg k}$ time, degree queries in
constant time, and the listing of neighbours in $\OhOf{\deg{v}}$ time.

A third strategy for succinct graph representations is based on graph
partitions.
Aleardi \etal~\cite{DBLP:conf/wads/AleardiDS05}
introduced a succinct representation for triangulations with a
boundary based on a hierarchical partition of the triangulation.
The combinatorial structure of the triangulation is partitioned into small
sub-triangulations which are further partitioned into tiny
sub-triangulations.
The representation stores the connectivity
information with asymptotically 2.175 bits per triangle, and supports
navigation between triangles in constant time.
The same authors presented an improved result of 1.62 bits per triangle for
triangulations without a boundary, and also demonstrated that
3-connected planar graphs can be represented with 2 bits per edge
\cite{DBLP:journals/tcs/AleardiDS08}.
For both planar triangulations and 3-connected planar graphs, this
representation permits constant-time navigation using additional
$\OhOf{N \lg \lg N \mathop{/} \lg N}$ bits of storage.
A partitioning approach was also
employed by Blandford \cite{DBLP:conf/soda/BlandfordBK03}, who showed
that graphs with small separators can be represented using $\OhOf{N}$
bits and such that adjacency and degree queries can be answered in
constant time and listing the neighbours of a vertex takes
$\OhOf{\deg{v}}$ time.

Farzan and Munro \cite{DBLP:conf/esa/FarzanM08} considered
the case of succinct representations of arbitrary graphs.
They described an encoding that requires
$(1 + \epsilon) \lg \parensXL{\genfrac{}{}{0pt}{}{N^2}{M}}$ bits,
for an arbitrarily small constant $\epsilon > 0$,
and supports adjacency and degree queries in constant
time, and the listing of neighbours in $\OhOf{\deg{v}}$ time.

Little work has focused on obtaining succinct EM data structures.
The only results of which we are aware focus on text indexing \cite{DBLP:conf/dcc/ChienHSV08,
  clark_96}, and on path traversals in trees \cite{DillabaughHM08}.

% ------------------------------------------------------------------------------
\subsection{Our Contributions}
% ------------------------------------------------------------------------------

In this paper, we present the following results:

\begin{enumerate}
\item In Section \ref{sec:graph_rep}, we present a data structure that
  uses $Nq + \OhOf{N} + \ohOf{Nq}$ bits to represent a planar graph with $N$
  vertices, each with a label of size $q$, and which allows the traversal of
  any path of length $K$ using $O(K / \lg B)$ I/Os.
  This path traversal cost matches that achieved by the data structure of
  Agarwal \etal~\cite{DBLP:conf/soda/AgarwalAMVV98}, but the latter
  uses $\ThetaOf{N \lg N} + 2Nq$ bits to store the graph.
  In the context of large datasets, this space saving represents a
  considerable improvement.
  (e.g., with keys of constant size, the space bound improves by
  a factor of $\lg N$.)
\item In Section \ref{sec:tins}, we apply our structure to store
  triangulations.
  If storing a point requires $\bitsPerPoint$ bits, we are able to store a triangulation in
  $N \bitsPerPoint + \OhOf{N} + \ohOf{N \bitsPerPoint}$ bits so that any path crossing $K$
  triangles can be traversed using $\OhOf{K / \lg B}$ I/Os.
  Again, the I/O efficiency of our structure matches that
  of~\cite{DBLP:conf/soda/AgarwalAMVV98} with a similar space improvement
  as for bounded-degree planar graphs.
\item In Section \ref{sec:point_location}, we show how to
  augment our triangulation representation with $\ohOf{N\bitsPerPoint}$ bits of extra
  information in order to support point location 
  queries using $\OhOf{\log_B N}$ I/Os.
  Asymptotically, this does not change the space requirements.
\item In Section \ref{sec:applications}, we describe several
  applications that make use of our representation for triangulations
  from Section~\ref{sec:tins}.
  We demonstrate that reporting terrain profiles and trickle paths takes
  $\BigOh{K / \lg B}$ I/Os.
  We show that connected-component queries---that is, reporting a set of
  triangles that share a common attribute and induce a connected
  subgraph in the triangulation's dual---can be performed using
  $\BigOh{K / \lg B}$ I/Os when the component being reported is convex and consists
  of $K$ triangles.
  For non-convex regions with holes, we achieve a query bound of
  $\BigOh{K / \lg B + h \log_B h}$, where $h$ is the number
  of edges on the component's boundary.
  In order to achieve this query bound, the query procedure uses
  $\BigOh{h \cdot (\bitsPerKey + \lg h)}$ extra space.
  Without using any extra space, the same query can be answered using
  $\BigOh{K / \lg B + h' \log_B h'}$ I/Os, where $h'$ is the number of
  triangles that are incident on the boundary of the component.
\end{enumerate}

%%% Local Variables:
%%% TeX-PDF-mode: t
%%% TeX-master: "main"
%%% End:
